#!/usr/bin/env python3

#1. 导入模块
import fibo

fibo.fib(1000)

print(fibo.fib2(100))

print(fibo.__name__)

#使用变量赋值为函数
fib = fibo.fib
fib2 = fibo.fib2

fib(500)
print(fib2(1000))

#.1 import 语句的一个变体直接从被导入的模块中导入命名到本模块的语义表中。例如:
# from fibo import fib, fib2
# 
#.2 也可以导入所有的定义
# from fibo import *
# 这样可以导入所有除了以下划线( _ )开头的命名。
# 
#.3 需要注意的是在实践中往往不鼓励从一个模块或包中使用 * 导入所有，因为这样会让代码变得很难读。不过，在交互式会话中这样用很方便省力。
#  出于性能考虑，每个模块在每个解释器会话中只导入一遍。
#   因此，如果你修改了你的模块，需要重启解释器；
#   或者，如果你就是想交互式的测试这么一个模块，可以用 imp.reload() 重新加载，例如 import imp; imp.reload(modulename)。
# 
#1. 作为脚本来执行模块
# python fibo.py <argumants>
#  模块中的代码会被执行，就像导入它一样，不过此时 __name__ 被设置为 "__main__"。这相当于，如果你在模块后加入如下代码:
#   if __name__ == "__main__":
#     import sys
#     fib(int(sys.argv[1]))
#
# 如果模块被导入，不会执行这段代码:
# import fibo
# 
# 这通常用来为模块提供一个便于测试的用户接口（将模块作为脚本执行测试需求）

#2. 模块搜索路径
# 导入一个叫 spam 的模块时，
#   解释器先在当前目录中搜索名为 spam.py 的文件。
#   如果没有找到的话，接着会到 sys.path 变量中给出的目录列表中查找。
#     sys.path 变量的初始值来自如下：
#     1. 输入脚本的目录（当前目录）。
#     2. 环境变量 PYTHONPATH 表示的目录列表中搜索
#       (这和 shell 变量 PATH 具有一样的语法，即一系列目录名的列表)。
#     3. Python 默认安装路径中搜索。
#     xxx: 在支持符号连接的文件系统中，输入的脚本所在的目录是符号连接指向的目录。 换句话说也就是包含符号链接的目录不会被加到目录搜索路径中。
#     这些路径中不要有和标准库重名的脚本，如果有的话，会在导入时将这些脚本当做模块来导入，会导致错误。

#3. “编译的” Python 文件
#  Python 不检查在两个不同环境中的缓存。
#   首先，它会永远重新编译而且不会存储直接从命令行加载的模块。
#   其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。
# 部分高级技巧:
#   1.为了减少一个编译模块的大小，你可以在 Python 命令行中使用 -O 或者 -OO。-O 参数删除了断言语句，-OO 参数删除了断言语句和 __doc__ 字符串。
#   2.因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。“优化的” 模块有一个 .pyo 后缀而不是 .pyc 后缀。未来的版本可能会改变优化的效果。
#   3.来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快；.pyc 或 .pyo 文件只是在它们加载的时候更快一些。
#   4.compileall 模块可以为指定目录中的所有模块创建 .pyc 文件（或者使用 -O 参数创建 .pyo 文件）。
#   5.在 PEP 3147 中有很多关这一部分内容的细节，并且包含了一个决策流程。
